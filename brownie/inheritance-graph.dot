digraph "" {
MarketPlace -> ERC1155Holder [ label="1" ];
MarketPlace -> Ownable [ label="2" ];
MarketPlace -> ReentrancyGuard [ label="3" ];
MarketPlace[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MarketPlace</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    listItemsForSale(address,address,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    purchaseItem(address,uint256)</TD></TR><TR><TD align="left">    getItemsOwned(address)</TD></TR><TR><TD align="left">    getListedItems()</TD></TR><TR><TD align="left">    delistItem(uint256)</TD></TR><TR><TD align="left">    relistItem(address,uint256,uint256)</TD></TR><TR><TD align="left">    getCurrentItemId()</TD></TR><TR><TD align="left">    getItemById(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    listItem(address,address,uint256,uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    royalties</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    itemIds</TD></TR><TR><TD align="left">    marketPlaceOwner</TD></TR><TR><TD align="left">    itemsMapping</TD></TR></TABLE> >];

Nft -> ERC1155 [ label="1" ];
Nft -> Ownable [ label="2" ];
Nft -> ReentrancyGuard [ label="3" ];
Nft[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Nft</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    mintToken(string,uint256,bytes)</TD></TR><TR><TD align="left">    setTokenURI(uint256,string)</TD></TR><TR><TD align="left">    checkIfOwner(uint256)</TD></TR><TR><TD align="left">    getCurrentTokenID()</TD></TR><TR><TD align="left">    getTokenURI(uint256)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    marketplaceAddress</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    tokenIds</TD></TR><TR><TD align="left">    _uris</TD></TR></TABLE> >];

IERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

IERC1155 -> IERC165;
IERC1155[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address,uint256)</TD></TR><TR><TD align="left">    balanceOfBatch(address[],uint256[])</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

IERC1155Receiver -> IERC165;
IERC1155Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC1155Received(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

ERC1155Holder -> ERC1155Receiver;
ERC1155Holder[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Holder</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155Received(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</font></TD></TR></TABLE> >];

ERC165 -> IERC165;
ERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR></TABLE> >];

ERC1155Receiver -> ERC165 [ label="1" ];
ERC1155Receiver -> IERC1155Receiver [ label="2" ];
ERC1155Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR></TABLE> >];

Address[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Address</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    _verifyCallResult(bool,bytes,string)</TD></TR></TABLE> >];

ReentrancyGuard[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ReentrancyGuard</B></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonReentrant()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _NOT_ENTERED</TD></TR><TR><TD align="left">    _ENTERED</TD></TR><TR><TD align="left">    _status</TD></TR></TABLE> >];

IERC1155MetadataURI -> IERC1155;
IERC1155MetadataURI[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155MetadataURI</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    uri(uint256)</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

Counters[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Counters</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    current(Counters.Counter)</TD></TR><TR><TD align="left">    increment(Counters.Counter)</TD></TR><TR><TD align="left">    decrement(Counters.Counter)</TD></TR><TR><TD align="left">    reset(Counters.Counter)</TD></TR></TABLE> >];

ERC1155 -> Context [ label="1" ];
ERC1155 -> ERC165 [ label="2" ];
ERC1155 -> IERC1155 [ label="3" ];
ERC1155 -> IERC1155MetadataURI [ label="4" ];
ERC1155[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    uri(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOfBatch(address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _setURI(string)</TD></TR><TR><TD align="left">    _mint(address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _mintBatch(address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    _burnBatch(address,uint256[],uint256[])</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _doSafeTransferAcceptanceCheck(address,address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _doSafeBatchTransferAcceptanceCheck(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _asSingletonArray(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR><TR><TD align="left">    _uri</TD></TR></TABLE> >];

Ownable -> Context;
Ownable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Ownable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _setOwner(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

}